## Produção ##

## Comandos
ssh -i /Users/jeanlessa/wall_projects/aws/webserver-dev.pem ubuntu@10.0.1.46

docker-compose build --no-cache web riskengine celery-worker celery-beat
docker-compose down
docker-compose up -d web riskengine celery-worker celery-beat

docker-compose restart web riskengine celery-worker celery-beat




docker system prune -a
docker logs wallclub-prod-oauth
git checkout feature/multi-app-security

## REDIS
docker network create wallclub-network

docker stop wallclub-redis && docker rm wallclub-redis
docker run -d \
  --name wallclub-redis \
  --network wallclub-network \
  --restart=always \
  redis:7-alpine redis-server --appendonly yes

## DJANGO
git pull origin feature/multi-app-security
docker stop wallclub-prod-release300 && docker rm wallclub-prod-release300
docker build -t wallclub-django:v1.0 .

docker run -d \
  --name wallclub-prod-release300 \
  --network wallclub-network \
  -v $(pwd)/media:/app/media \
  -p 8003:8000 \
  --env-file .env \
  --restart=always \
  -v $(pwd)/logs:/app/logs \
  --memory=2g \
  --memory-swap=2g \
  --cpus="1.5" \
  --oom-kill-disable=false \
  wallclub-django:v1.0


## TODOS OS CONTAINERS (Django + Risk Engine + Celery) ##
# Orquestração centralizada no projeto principal

# IMPORTANTE: Instalar Docker Compose se não estiver instalado
# sudo apt install docker-compose

cd /path/to/wallclub_django

# Pull dos 2 projetos
git pull origin feature/multi-app-security
cd ../wallclub_django_risk_engine && git pull origin main && cd ../wallclub_django

# Parar containers antigos (se existirem)
docker stop wallclub-prod-release300 wallclub-riskengine wallclub-celery-worker wallclub-celery-beat 2>/dev/null
docker rm wallclub-prod-release300 wallclub-riskengine wallclub-celery-worker wallclub-celery-beat 2>/dev/null

# OPÇÃO 1: Subir TODOS os 5 containers (primeira vez ou mudanças no Redis)
# Containers: wallclub-prod-release300 (8000), wallclub-redis (6379),
#             wallclub-riskengine (8004), wallclub-celery-worker, wallclub-celery-beat
docker-compose down
docker-compose up -d --build

# OPÇÃO 2: Deploy de rotina (atualizar código Django + Risk Engine)
# IMPORTANTE: Parar containers ANTES do build para evitar erro ContainerConfig
git pull origin feature/multi-app-security
docker-compose stop web riskengine celery-worker celery-beat
docker-compose rm -f web riskengine celery-worker celery-beat
docker-compose build --no-cache web riskengine celery-worker celery-beat
docker-compose up -d --build web riskengine celery-worker celery-beat
docker exec wallclub-redis redis-cli FLUSHALL


git pull origin feature/multi-app-security
docker-compose stop web
docker-compose rm -f web
docker-compose build --no-cache web
docker-compose up -d --build web

git pull origin multiplos_containers
docker-compose stop web
docker-compose rm -f web
docker-compose build web
docker-compose up -d web
docker exec wallclub-redis redis-cli FLUSHALL


# Verificar status de TODOS os containers
docker-compose ps

# Ver logs individuais (opcional)
docker-compose logs -f web             # Django principal
docker-compose logs -f riskengine      # APIs antifraude

# ⚠️ TROUBLESHOOTING: Erro KeyError 'ContainerConfig'
# Se aparecer esse erro, cache do Docker corrompido:
# Execute: bash scripts/fix_docker_error.sh
# (Só necessário 1x quando erro aparecer, não em todo deploy)
docker-compose logs -f celery-worker   # Tasks assíncronas
docker-compose logs -f celery-beat     # Scheduler


## LIMPEZA DE CONTAINERS E IMAGENS (MANUTENÇÃO) ##

# Parar todos os containers
docker-compose down

# Remover containers parados
docker container prune -f

# Remover imagens não utilizadas (libera espaço)
docker image prune -a -f

# Limpeza completa (containers + imagens + networks + cache de build)
# CUIDADO: Remove TODAS as imagens não utilizadas
docker system prune -a -f

# Limpeza completa incluindo VOLUMES (perde dados do Redis!)
# MUITO CUIDADO: Só use se quiser limpar TUDO
# docker system prune -a -f --volumes

# Verificar espaço recuperado
docker system df


